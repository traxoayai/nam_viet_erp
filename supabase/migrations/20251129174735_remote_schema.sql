create type "public"."business_type" as enum ('trade', 'advance', 'reimbursement', 'internal', 'other');

create type "public"."transaction_flow" as enum ('in', 'out');

create type "public"."transaction_status" as enum ('pending', 'confirmed', 'cancelled');

drop function if exists "public"."get_suppliers_list"(search_query text, status_filter text, page_num integer, page_size integer);


  create table "public"."finance_transactions" (
    "id" bigint generated by default as identity not null,
    "code" text not null,
    "transaction_date" timestamp with time zone not null default now(),
    "flow" public.transaction_flow not null,
    "business_type" public.business_type not null default 'other'::public.business_type,
    "category_id" bigint,
    "amount" numeric not null,
    "fund_account_id" bigint not null,
    "partner_type" text,
    "partner_id" text,
    "partner_name_cache" text,
    "ref_type" text,
    "ref_id" text,
    "description" text,
    "evidence_url" text,
    "created_by" uuid default auth.uid(),
    "created_at" timestamp with time zone default now(),
    "status" public.transaction_status not null default 'pending'::public.transaction_status,
    "cash_tally" jsonb,
    "ref_advance_id" bigint,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."finance_transactions" enable row level security;

alter table "public"."fund_accounts" add column "balance" numeric not null default 0;

alter table "public"."fund_accounts" add column "bank_info" jsonb;

alter table "public"."fund_accounts" add column "currency" text default 'VND'::text;

alter table "public"."fund_accounts" add column "description" text;

alter table "public"."suppliers" add column "bank_bin" text;

CREATE UNIQUE INDEX finance_transactions_code_key ON public.finance_transactions USING btree (code);

CREATE UNIQUE INDEX finance_transactions_pkey ON public.finance_transactions USING btree (id);

CREATE INDEX idx_finance_trans_category ON public.finance_transactions USING btree (category_id);

CREATE INDEX idx_finance_trans_code_trgm ON public.finance_transactions USING gin (code public.gin_trgm_ops);

CREATE INDEX idx_finance_trans_created_by ON public.finance_transactions USING btree (created_by);

CREATE INDEX idx_finance_trans_date ON public.finance_transactions USING btree (transaction_date DESC);

CREATE INDEX idx_finance_trans_desc_trgm ON public.finance_transactions USING gin (description public.gin_trgm_ops);

CREATE INDEX idx_finance_trans_fund ON public.finance_transactions USING btree (fund_account_id);

CREATE INDEX idx_finance_trans_partner ON public.finance_transactions USING btree (partner_type, partner_id);

CREATE INDEX idx_finance_trans_partner_name_trgm ON public.finance_transactions USING gin (partner_name_cache public.gin_trgm_ops);

CREATE INDEX idx_finance_trans_ref ON public.finance_transactions USING btree (ref_type, ref_id);

CREATE INDEX idx_finance_trans_ref_advance ON public.finance_transactions USING btree (ref_advance_id);

CREATE INDEX idx_finance_trans_status ON public.finance_transactions USING btree (status);

alter table "public"."finance_transactions" add constraint "finance_transactions_pkey" PRIMARY KEY using index "finance_transactions_pkey";

alter table "public"."finance_transactions" add constraint "finance_transactions_amount_check" CHECK ((amount > (0)::numeric)) not valid;

alter table "public"."finance_transactions" validate constraint "finance_transactions_amount_check";

alter table "public"."finance_transactions" add constraint "finance_transactions_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.transaction_categories(id) not valid;

alter table "public"."finance_transactions" validate constraint "finance_transactions_category_id_fkey";

alter table "public"."finance_transactions" add constraint "finance_transactions_code_key" UNIQUE using index "finance_transactions_code_key";

alter table "public"."finance_transactions" add constraint "finance_transactions_fund_account_id_fkey" FOREIGN KEY (fund_account_id) REFERENCES public.fund_accounts(id) ON DELETE RESTRICT not valid;

alter table "public"."finance_transactions" validate constraint "finance_transactions_fund_account_id_fkey";

alter table "public"."finance_transactions" add constraint "finance_transactions_ref_advance_id_fkey" FOREIGN KEY (ref_advance_id) REFERENCES public.finance_transactions(id) not valid;

alter table "public"."finance_transactions" validate constraint "finance_transactions_ref_advance_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.confirm_finance_transaction(p_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_current_status public.transaction_status;
BEGIN
    -- Kiểm tra trạng thái
    SELECT status INTO v_current_status FROM public.finance_transactions WHERE id = p_id;
    
    IF v_current_status = 'confirmed' THEN
        RAISE EXCEPTION 'Giao dịch này đã được duyệt trước đó.';
    END IF;

    IF v_current_status = 'cancelled' THEN
        RAISE EXCEPTION 'Không thể duyệt giao dịch đã bị hủy.';
    END IF;

    -- Cập nhật (Trigger sẽ tự động trừ tiền quỹ)
    UPDATE public.finance_transactions 
    SET status = 'confirmed', updated_at = now()
    WHERE id = p_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.confirm_transaction(p_id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_current_status public.transaction_status;
BEGIN
    -- 1. Kiểm tra trạng thái hiện tại
    SELECT status INTO v_current_status FROM public.finance_transactions WHERE id = p_id;
    
    IF v_current_status = 'confirmed' THEN
        RAISE EXCEPTION 'Giao dịch này đã được duyệt trước đó.';
    END IF;

    IF v_current_status = 'cancelled' THEN
        RAISE EXCEPTION 'Không thể duyệt giao dịch đã bị hủy.';
    END IF;

    -- 2. Cập nhật trạng thái -> Trigger sẽ tự động trừ/cộng tiền
    UPDATE public.finance_transactions 
    SET status = 'confirmed', updated_at = now()
    WHERE id = p_id;

    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_finance_transaction(p_flow public.transaction_flow, p_business_type public.business_type, p_fund_account_id bigint, p_amount numeric, p_category_id bigint DEFAULT NULL::bigint, p_partner_type text DEFAULT NULL::text, p_partner_id text DEFAULT NULL::text, p_partner_name text DEFAULT NULL::text, p_ref_type text DEFAULT NULL::text, p_ref_id text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_evidence_url text DEFAULT NULL::text)
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_new_id BIGINT;
    v_code TEXT;
    v_prefix TEXT;
    v_partner_name_final TEXT;
BEGIN
    -- 1. Xác định Tiền tố (PT = Phiếu Thu, PC = Phiếu Chi)
    IF p_flow = 'in' THEN v_prefix := 'PT'; ELSE v_prefix := 'PC'; END IF;
    
    -- 2. Sinh mã phiếu: PT-YYMMDD-XXXX (Random 4 số)
    v_code := v_prefix || '-' || to_char(now(), 'YYMMDD') || '-' || lpad(floor(random() * 10000)::text, 4, '0');

    -- 3. Xử lý tên đối tác (Nếu không truyền vào thì thử tìm trong DB)
    -- (Logic này giúp tối ưu hiển thị lịch sử mà không cần join quá nhiều bảng)
    v_partner_name_final := p_partner_name;
    IF v_partner_name_final IS NULL AND p_partner_id IS NOT NULL THEN
        IF p_partner_type = 'supplier' THEN
            SELECT name INTO v_partner_name_final FROM public.suppliers WHERE id = p_partner_id::bigint;
        ELSIF p_partner_type = 'customer' THEN
            SELECT name INTO v_partner_name_final FROM public.customers WHERE id = p_partner_id::bigint;
        ELSIF p_partner_type = 'customer_b2b' THEN
            SELECT name INTO v_partner_name_final FROM public.customers_b2b WHERE id = p_partner_id::bigint;
        ELSIF p_partner_type = 'employee' THEN
            SELECT full_name INTO v_partner_name_final FROM public.users WHERE id = p_partner_id::uuid;
        END IF;
    END IF;

    -- 4. Insert
    INSERT INTO public.finance_transactions (
        code, flow, business_type, category_id,
        amount, fund_account_id,
        partner_type, partner_id, partner_name_cache,
        ref_type, ref_id,
        description, evidence_url, created_by
    ) VALUES (
        v_code, p_flow, p_business_type, p_category_id,
        p_amount, p_fund_account_id,
        p_partner_type, p_partner_id, v_partner_name_final,
        p_ref_type, p_ref_id,
        p_description, p_evidence_url, auth.uid()
    )
    RETURNING id INTO v_new_id;

    RETURN v_new_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_finance_transaction(p_flow public.transaction_flow, p_business_type public.business_type, p_fund_account_id bigint, p_amount numeric, p_category_id bigint DEFAULT NULL::bigint, p_partner_type text DEFAULT NULL::text, p_partner_id text DEFAULT NULL::text, p_partner_name text DEFAULT NULL::text, p_ref_type text DEFAULT NULL::text, p_ref_id text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_evidence_url text DEFAULT NULL::text, p_status public.transaction_status DEFAULT 'pending'::public.transaction_status, p_cash_tally jsonb DEFAULT NULL::jsonb, p_ref_advance_id bigint DEFAULT NULL::bigint)
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_new_id BIGINT;
    v_code TEXT;
    v_prefix TEXT;
    v_partner_name_final TEXT;
BEGIN
    -- 1. Tiền tố
    IF p_flow = 'in' THEN v_prefix := 'PT'; ELSE v_prefix := 'PC'; END IF;
    
    -- 2. Sinh mã phiếu
    v_code := v_prefix || '-' || to_char(now(), 'YYMMDD') || '-' || lpad(floor(random() * 10000)::text, 4, '0');

    -- 3. Lookup tên đối tác (nếu cần)
    v_partner_name_final := p_partner_name;
    IF v_partner_name_final IS NULL AND p_partner_id IS NOT NULL THEN
        -- (Giữ nguyên logic lookup như V1)
        IF p_partner_type = 'supplier' THEN
            SELECT name INTO v_partner_name_final FROM public.suppliers WHERE id = p_partner_id::bigint;
        ELSIF p_partner_type = 'customer' THEN
            SELECT name INTO v_partner_name_final FROM public.customers WHERE id = p_partner_id::bigint;
        ELSIF p_partner_type = 'customer_b2b' THEN
            SELECT name INTO v_partner_name_final FROM public.customers_b2b WHERE id = p_partner_id::bigint;
        ELSIF p_partner_type = 'employee' THEN
            SELECT full_name INTO v_partner_name_final FROM public.users WHERE id = p_partner_id::uuid;
        END IF;
    END IF;

    -- 4. Insert V2
    INSERT INTO public.finance_transactions (
        code, flow, business_type, category_id,
        amount, fund_account_id,
        partner_type, partner_id, partner_name_cache,
        ref_type, ref_id,
        description, evidence_url, created_by,
        -- Cột mới
        status, cash_tally, ref_advance_id
    ) VALUES (
        v_code, p_flow, p_business_type, p_category_id,
        p_amount, p_fund_account_id,
        p_partner_type, p_partner_id, v_partner_name_final,
        p_ref_type, p_ref_id,
        p_description, p_evidence_url, auth.uid(),
        p_status, p_cash_tally, p_ref_advance_id
    )
    RETURNING id INTO v_new_id;

    RETURN v_new_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_transaction_history(p_flow public.transaction_flow DEFAULT NULL::public.transaction_flow, p_fund_id bigint DEFAULT NULL::bigint, p_date_from timestamp with time zone DEFAULT NULL::timestamp with time zone, p_date_to timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0)
 RETURNS TABLE(id bigint, code text, transaction_date timestamp with time zone, flow public.transaction_flow, amount numeric, fund_name text, partner_name text, category_name text, description text, business_type public.business_type, created_by_name text, total_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.code,
        t.transaction_date,
        t.flow,
        t.amount,
        f.name as fund_name,
        COALESCE(t.partner_name_cache, 'Khác') as partner_name,
        cat.name as category_name,
        t.description,
        t.business_type,
        u.full_name as created_by_name,
        COUNT(*) OVER() as total_count
    FROM public.finance_transactions t
    JOIN public.fund_accounts f ON t.fund_account_id = f.id
    LEFT JOIN public.transaction_categories cat ON t.category_id = cat.id
    LEFT JOIN public.users u ON t.created_by = u.id
    WHERE 
        (p_flow IS NULL OR t.flow = p_flow)
        AND (p_fund_id IS NULL OR t.fund_account_id = p_fund_id)
        AND (p_date_from IS NULL OR t.transaction_date >= p_date_from)
        AND (p_date_to IS NULL OR t.transaction_date <= p_date_to)
    ORDER BY t.transaction_date DESC
    LIMIT p_limit OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_transaction_history(p_flow public.transaction_flow DEFAULT NULL::public.transaction_flow, p_fund_id bigint DEFAULT NULL::bigint, p_date_from timestamp with time zone DEFAULT NULL::timestamp with time zone, p_date_to timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_keyword text DEFAULT NULL::text, p_created_by uuid DEFAULT NULL::uuid, p_status public.transaction_status DEFAULT NULL::public.transaction_status)
 RETURNS TABLE(id bigint, code text, transaction_date timestamp with time zone, flow public.transaction_flow, amount numeric, fund_name text, partner_name text, category_name text, description text, business_type public.business_type, created_by_name text, status public.transaction_status, ref_advance_id bigint, ref_advance_code text, total_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.code,
        t.transaction_date,
        t.flow,
        t.amount,
        f.name as fund_name,
        COALESCE(t.partner_name_cache, 'Khác') as partner_name,
        cat.name as category_name,
        t.description,
        t.business_type,
        u.full_name as created_by_name,
        t.status,
        t.ref_advance_id,
        parent.code as ref_advance_code, -- Self-join để lấy mã phiếu gốc
        COUNT(*) OVER() as total_count
    FROM public.finance_transactions t
    JOIN public.fund_accounts f ON t.fund_account_id = f.id
    LEFT JOIN public.transaction_categories cat ON t.category_id = cat.id
    LEFT JOIN public.users u ON t.created_by = u.id
    LEFT JOIN public.finance_transactions parent ON t.ref_advance_id = parent.id
    WHERE 
        (p_flow IS NULL OR t.flow = p_flow)
        AND (p_fund_id IS NULL OR t.fund_account_id = p_fund_id)
        AND (p_date_from IS NULL OR t.transaction_date >= p_date_from)
        AND (p_date_to IS NULL OR t.transaction_date <= p_date_to)
        AND (p_status IS NULL OR t.status = p_status)
        AND (p_created_by IS NULL OR t.created_by = p_created_by)
        AND (
            p_keyword IS NULL OR 
            t.code ILIKE '%' || p_keyword || '%' OR 
            t.description ILIKE '%' || p_keyword || '%'
        )
    ORDER BY t.transaction_date DESC
    LIMIT p_limit OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_transaction_history(p_flow public.transaction_flow DEFAULT NULL::public.transaction_flow, p_fund_id bigint DEFAULT NULL::bigint, p_date_from timestamp with time zone DEFAULT NULL::timestamp with time zone, p_date_to timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_search text DEFAULT NULL::text, p_status text DEFAULT NULL::text)
 RETURNS TABLE(id bigint, code text, transaction_date timestamp with time zone, flow public.transaction_flow, amount numeric, fund_name text, partner_name text, category_name text, description text, business_type public.business_type, created_by_name text, status public.transaction_status, ref_advance_id bigint, total_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.code,
        t.transaction_date,
        t.flow,
        t.amount,
        f.name as fund_name,
        COALESCE(t.partner_name_cache, 'Khác') as partner_name,
        cat.name as category_name,
        t.description,
        t.business_type,
        u.full_name as created_by_name,
        t.status,
        t.ref_advance_id,
        -- Đếm tổng số bản ghi (cho phân trang)
        COUNT(*) OVER() as total_count
    FROM public.finance_transactions t
    JOIN public.fund_accounts f ON t.fund_account_id = f.id
    LEFT JOIN public.transaction_categories cat ON t.category_id = cat.id
    LEFT JOIN public.users u ON t.created_by = u.id
    WHERE 
        (p_flow IS NULL OR t.flow = p_flow)
        AND (p_fund_id IS NULL OR t.fund_account_id = p_fund_id)
        AND (p_date_from IS NULL OR t.transaction_date >= p_date_from)
        AND (p_date_to IS NULL OR t.transaction_date <= p_date_to)
        -- Logic lọc Status (Cast text sang enum)
        AND (p_status IS NULL OR t.status = p_status::public.transaction_status)
        -- Logic tìm kiếm thông minh (Mã phiếu OR Mô tả OR Tên đối tác)
        AND (
            p_search IS NULL OR p_search = '' OR 
            t.code ILIKE '%' || p_search || '%' OR 
            t.description ILIKE '%' || p_search || '%' OR
            t.partner_name_cache ILIKE '%' || p_search || '%'
        )
    ORDER BY t.transaction_date DESC
    LIMIT p_limit OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_fund_balance_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- TRƯỜNG HỢP 1: DUYỆT PHIẾU (Pending -> Confirmed)
    -- Hoặc tạo mới phiếu đã Confirm ngay từ đầu
    IF (TG_OP = 'UPDATE' AND NEW.status = 'confirmed' AND OLD.status != 'confirmed') 
       OR (TG_OP = 'INSERT' AND NEW.status = 'confirmed') THEN
       
        IF NEW.flow = 'in' THEN
            UPDATE public.fund_accounts 
            SET balance = balance + NEW.amount, updated_at = now() 
            WHERE id = NEW.fund_account_id;
        ELSIF NEW.flow = 'out' THEN
            UPDATE public.fund_accounts 
            SET balance = balance - NEW.amount, updated_at = now() 
            WHERE id = NEW.fund_account_id;
        END IF;

    -- TRƯỜNG HỢP 2: HỦY PHIẾU ĐÃ DUYỆT (Confirmed -> Cancelled) -> Hoàn tiền lại quỹ
    ELSIF (TG_OP = 'UPDATE' AND NEW.status = 'cancelled' AND OLD.status = 'confirmed') THEN
        IF OLD.flow = 'in' THEN
            UPDATE public.fund_accounts SET balance = balance - OLD.amount WHERE id = OLD.fund_account_id;
        ELSIF OLD.flow = 'out' THEN
            UPDATE public.fund_accounts SET balance = balance + OLD.amount WHERE id = OLD.fund_account_id;
        END IF;

    -- TRƯỜNG HỢP 3: XÓA PHIẾU ĐÃ DUYỆT (Cực kỳ hạn chế, nhưng cần handle)
    ELSIF (TG_OP = 'DELETE' AND OLD.status = 'confirmed') THEN
        IF OLD.flow = 'in' THEN
            UPDATE public.fund_accounts SET balance = balance - OLD.amount WHERE id = OLD.fund_account_id;
        ELSIF OLD.flow = 'out' THEN
            UPDATE public.fund_accounts SET balance = balance + OLD.amount WHERE id = OLD.fund_account_id;
        END IF;
    END IF;

    RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_supplier(p_name text, p_tax_code text, p_contact_person text, p_phone text, p_email text, p_address text, p_payment_term text, p_bank_account text, p_bank_name text, p_bank_holder text, p_delivery_method text, p_lead_time integer, p_status text, p_notes text)
 RETURNS bigint
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_supplier_id BIGINT;
    v_bank_bin TEXT;
BEGIN
    -- LOGIC TỰ ĐỘNG TÌM BIN NGÂN HÀNG
    -- Tìm theo tên đầy đủ HOẶC tên viết tắt (short_name)
    IF p_bank_name IS NOT NULL AND p_bank_name <> '' THEN
        SELECT bin INTO v_bank_bin 
        FROM public.banks 
        WHERE name ILIKE p_bank_name 
           OR short_name ILIKE p_bank_name 
           OR code ILIKE p_bank_name
        LIMIT 1;
    END IF;

    -- Insert với bank_bin tự động
    INSERT INTO public.suppliers (
        name, tax_code, contact_person, phone, email, address, 
        payment_term, bank_account, bank_name, bank_holder, delivery_method, lead_time,
        status, notes, 
        bank_bin -- Cột mới
    )
    VALUES (
        p_name, p_tax_code, p_contact_person, p_phone, p_email, p_address, 
        p_payment_term, p_bank_account, p_bank_name, p_bank_holder, p_delivery_method, p_lead_time,
        p_status, p_notes,
        v_bank_bin -- Giá trị tự động tìm được
    )
    RETURNING id INTO v_supplier_id;
    
    RETURN v_supplier_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_suppliers_list(search_query text, status_filter text, page_num integer, page_size integer)
 RETURNS TABLE(id bigint, key text, code text, name text, contact_person text, phone text, status text, debt numeric, bank_bin text, bank_account text, bank_name text, total_count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    WITH filtered_suppliers AS (
        SELECT 
            s.id,
            s.id::TEXT AS key,
            'NCC-' || s.id::TEXT AS code,
            s.name,
            s.contact_person,
            s.phone,
            s.status,
            0::NUMERIC AS debt, -- (Sẽ tích hợp module Công nợ sau)
            
            -- Trả về thông tin ngân hàng
            s.bank_bin,
            s.bank_account,
            s.bank_name,
            
            COUNT(*) OVER() as total_count
        FROM 
            public.suppliers s
        WHERE 
            (search_query IS NULL OR search_query = '' OR (
                s.name ILIKE ('%' || search_query || '%') OR
                s.phone ILIKE ('%' || search_query || '%') OR
                s.id::TEXT ILIKE ('%' || search_query || '%')
            ))
        AND 
            (status_filter IS NULL OR s.status = status_filter)
    )
    SELECT *
    FROM filtered_suppliers
    ORDER BY id DESC
    LIMIT page_size 
    OFFSET (page_num - 1) * page_size;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_supplier(p_id bigint, p_name text, p_tax_code text, p_contact_person text, p_phone text, p_email text, p_address text, p_payment_term text, p_bank_account text, p_bank_name text, p_bank_holder text, p_delivery_method text, p_lead_time integer, p_status text, p_notes text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_bank_bin TEXT;
BEGIN
    -- LOGIC TỰ ĐỘNG TÌM BIN (Giống hàm Create)
    IF p_bank_name IS NOT NULL AND p_bank_name <> '' THEN
        SELECT bin INTO v_bank_bin 
        FROM public.banks 
        WHERE name ILIKE p_bank_name 
           OR short_name ILIKE p_bank_name 
           OR code ILIKE p_bank_name
        LIMIT 1;
    END IF;

    UPDATE public.suppliers
    SET
        name = p_name,
        tax_code = p_tax_code,
        contact_person = p_contact_person,
        phone = p_phone,
        email = p_email,
        address = p_address,
        payment_term = p_payment_term,
        bank_account = p_bank_account,
        bank_name = p_bank_name,
        bank_holder = p_bank_holder,
        delivery_method = p_delivery_method,
        lead_time = p_lead_time,
        status = p_status,
        notes = p_notes,
        bank_bin = v_bank_bin -- Cập nhật tự động
    WHERE id = p_id;
END;
$function$
;

grant delete on table "public"."finance_transactions" to "anon";

grant insert on table "public"."finance_transactions" to "anon";

grant references on table "public"."finance_transactions" to "anon";

grant select on table "public"."finance_transactions" to "anon";

grant trigger on table "public"."finance_transactions" to "anon";

grant truncate on table "public"."finance_transactions" to "anon";

grant update on table "public"."finance_transactions" to "anon";

grant delete on table "public"."finance_transactions" to "authenticated";

grant insert on table "public"."finance_transactions" to "authenticated";

grant references on table "public"."finance_transactions" to "authenticated";

grant select on table "public"."finance_transactions" to "authenticated";

grant trigger on table "public"."finance_transactions" to "authenticated";

grant truncate on table "public"."finance_transactions" to "authenticated";

grant update on table "public"."finance_transactions" to "authenticated";

grant delete on table "public"."finance_transactions" to "service_role";

grant insert on table "public"."finance_transactions" to "service_role";

grant references on table "public"."finance_transactions" to "service_role";

grant select on table "public"."finance_transactions" to "service_role";

grant trigger on table "public"."finance_transactions" to "service_role";

grant truncate on table "public"."finance_transactions" to "service_role";

grant update on table "public"."finance_transactions" to "service_role";


  create policy "Enable all for authenticated"
  on "public"."finance_transactions"
  as permissive
  for all
  to authenticated
using (true);


CREATE TRIGGER on_finance_transaction_change AFTER INSERT OR DELETE OR UPDATE ON public.finance_transactions FOR EACH ROW EXECUTE FUNCTION public.handle_fund_balance_update();


  create policy "Allow authenticated uploads finance_evidence"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((bucket_id = 'finance_evidence'::text));



  create policy "Allow public view finance_evidence"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'finance_evidence'::text));



